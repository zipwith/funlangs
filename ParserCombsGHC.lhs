----------------------------------------------------------------------
CS 457/557 Functional Languages, Winter 2019

Parsers Combinators in Haskell
----------------------------------------------------------------------

This file provides a library for combinator parsing in Haskell.  This
particular library is intended for the purposes of illustrating basic
ideas and concepts; for production use of parser combinators,
something like the standard Parsec library would probably be a more
appropriate choice.

> module PC where

We'll write some simple parsers using characters, so I'll import the
Char library:

> import Data.Char

BASIC DEFINITIONS: ---------------------------------------------------

I'll define a parser to be a function that takes a list of characters
of type String as its input and returns a list of possible parses,
each of which is a pair of type (a, String).  In each such pair, the
first component is the result of the parse and the second component is
the list of remaining tokens (if any).  If there are no valid parses,
then we just return the empty list.

> data Parser a = P (String -> [(a, String)])

empty is a parser that never returns a successful parse:

> empty :: Parser a
> empty  = P (\s -> [])

item is a parser that consumes and returns the next input character,
if there is one:

> item  :: Parser Char
> item   = P (\s -> case s of
>                     []     -> []
>                     (c:cs) -> [(c,cs)])

We define a helper function for running a given parser on a particular
string and discard any results that do not consume all of the input.

> parse        :: Parser a -> String -> [(a, String)]
> parse (P p) s = p s

MAPPING: -------------------------------------------------------------

We can apply a function to each of the results produced by a parser
using the following variant of the standard map function.

> instance Functor Parser where
>   fmap f (P p) = P (\s -> [ (f x, s') | (x, s') <- p s ])

MONADIC RETURN AND BIND: ---------------------------------------------

> instance Monad Parser where
>   return x  = P (\s -> [(x, s)])
>   p >>= f   = P (\s -> [ r | (x, s') <- parse p s,
>                              r <- parse (f x) s' ])

(return x) is a parser that returns a given value, x, without consuming
any input tokens.  The "bind" operator, >>=, gives us a way to
combine two parsers in sequence: the results that are generated by
the left argument are passed as arguments to the function argument
on the right.

(sat p) is a parser that will parse a single character, so long as it
satisfies the predicate p:

> sat  :: (Char -> Bool) -> Parser Char
> sat p = do c <- item
>            if p c then return c
>                   else empty

Some examples using sat:

> digit, lower, upper :: Parser Char
> digit = sat isDigit
> lower = sat isLower
> upper = sat isUpper

> lowerDigit = do l <- lower
>                 d <- digit
>                 return [l,d]

APPLICATIVE STRUCTURE: -----------------------------------------------

> instance Applicative Parser where
>    pure x    = P (\s -> [(x,s)])
>    pf <*> px = P (\s -> [ (f x, s'')
>                         | (f, s') <- parse pf s,
>                           (x, s'') <- parse px s' ])

ALTERNATIVES: --------------------------------------------------------

(p <|> q) returns all the ways that we can find to match the input
against p followed by all the ways that we can find to match the
input against q.

> (<|>)  :: Parser a -> Parser a -> Parser a
> p <|> q = P (\s -> parse p s ++ parse q s)

REPETITION: ----------------------------------------------------------

(some p) parses a sequence of zero or more things, each of which
matches p; think of this like a regular expression r*.  On the
other hand, (many p) parses a sequence of one or more things,
each of which is matched by the parser p; think of this like a
regular expression r+.

> some, many :: Parser a -> Parser [a]
> some p      = many p <|> return []
> many p      = do x  <- p
>                  xs <- some p
>                  return (x:xs)

PRUNING: -------------------------------------------------------------

Pruning is used to eliminate multiple return results from a parser;
this typically assumes that the first parse in the result list will
match more of the input than later parses.

> prune    :: Parser a -> Parser a
> prune p   = P (take 1 . parse p)

We provide a helper function to use in place of parse for parsers
that produce multiple outputs.

> first    :: Parser a -> String -> [(a, String)]
> first     = parse . prune

LEXICAL ANALYSIS: ----------------------------------------------------

Now we can start to define some basic parsers for recognizing:

Natural numbers:

> nat      :: Parser Int
> nat       = fmap read (many digit)

Spaces:

> space    :: Parser ()
> space     = do some (sat isSpace); return ()

Alphabetic characters:

> letter   :: Parser Char
> letter    = lower <|> upper

Alphanumeric characters:

> alphanum :: Parser Char
> alphanum  = letter <|> digit

Identifiers:

> ident    :: Parser String
> ident     = do c  <- letter
>                cs <- some alphanum
>                return (c:cs)

Fixed strings:

> string       :: String -> Parser ()
> string []     = return ()
> string (x:xs) = do sat (x==)
>                    string xs

Tokens, optionally surrounded by spaces:

> token        :: Parser a -> Parser a
> token p       = do space
>                    v <- p
>                    space
>                    return v

Symbols, which are fixed strings/keywords with optional
spaces around them:

> symbol       :: String -> Parser ()
> symbol        = token . string

Identifier tokens:

> identifier   :: Parser String
> identifier    = token ident

Natural number tokens:

> natural      :: Parser Int
> natural       = token nat

Integers (with an optional negative sign):

> integer      :: Parser Int
> integer       = natural  <|>  (do symbol "-"
>                                   n <- natural
>                                   return (-n))

PARSING LISTS: -------------------------------------------------------

> list   :: Parser a -> Parser [a]
> list p  = do symbol "["
>              vs <- (do v  <- p
>                        vs <- some (do symbol "," ; p)
>                        return (v:vs))
>                    <|> return []
>              symbol "]"
>              return vs

This parser requires an opening "[" at the start of
the list and a closing "]" at the end.  In the middle,
we expect either a non-empty list (v:vs), where each
pair of elements are separate by a comma, or else an
empty list [].

EVALUATING ARITHMETIC EXPRESSIONS: -----------------------------------

Here's a grammar for simple integer-valued expressions:

  expr = term ("+" expr | "-" expr )?
  term = atom ("*" term | atom "/" )?
  atom = "-" atom
       | "(" expr ")"
       | number

And here is a parser that follows this grammar, and calculates the
integer value of a string containing a valid expression:

> expr :: Parser Int
> expr  = do l <- term
>            ((do symbol "+"; r <- expr; return (l+r)) <|>
>             (do symbol "-"; r <- expr; return (l-r)) <|>
>             return l)

> term :: Parser Int
> term  = do l <- atom
>            ((do symbol "*"; r <- term; return (l*r)) <|>
>             (do symbol "/"; r <- term; return (l `div` r)) <|>
>             return l)

> atom :: Parser Int
> atom  = (do symbol "-"; n <- atom; return (-n)) <|>
>         (do symbol "("; n <- expr; symbol ")"; return n) <|>
>         natural

----------------------------------------------------------------------
What if we want to obtain a data structure that describes expressions?
Here is a suitable datatype that we can use to describe the "abstract
syntax" of simple arithmetic expressions:

> data Expr = Add Expr Expr
>           | Sub Expr Expr
>           | Mul Expr Expr
>           | Div Expr Expr
>           | Neg Expr
>           | Num Int
>             deriving Show

And now we can adapt the parser we saw above to generate abstract
syntax values from input strings:

> absyn :: Parser Expr
> absyn  = expr
>  where 
>    expr  = do l <- term
>               ((do symbol "+"; r <- expr; return (Add l r)) <|>
>                (do symbol "-"; r <- expr; return (Sub l r)) <|>
>                return l)
>    term  = do l <- atom
>               ((do symbol "*"; r <- term; return (Mul l r)) <|>
>                (do symbol "/"; r <- term; return (Div l r)) <|>
>                return l)
>    atom  = (do symbol "-"; n <- atom; return (Neg n)) <|>
>            (do symbol "("; n <- expr; symbol ")"; return n) <|>
>            (fmap Num natural)

----------------------------------------------------------------------
We can easily go beyond context-free parsing in this framework:

- Read a number from the user and then parse that many things from the
  rest of the list.  For example, csp  will parse "1a" or "2aa" or
  "3aaa" or "4aaaa" or ...

> csp :: Parser String
> csp  = do n <- natural
>           sequence (replicate n item)

- Read a string of characters, enclosed in a matching pair of
  characters.  For example, this parser matches inputs like +hello+ or
  @hello@ or "hello" or ...

> brack :: Parser String
> brack  = do c  <- item
>             xs <- some (sat (c/=))
>             sat (c==)
>             return xs

----------------------------------------------------------------------
